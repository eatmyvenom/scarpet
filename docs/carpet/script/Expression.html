<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_191) on Wed Dec 11 23:28:26 AST 2019 -->
<title>Expression</title>
<meta name="date" content="2019-12-11">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Expression";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">carpet.script</div>
<h2 title="Class Expression" class="title">Class Expression</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>carpet.script.Expression</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd>java.lang.Cloneable</dd>
</dl>
<hr>
<br>
<pre>public class <span class="typeNameLabel">Expression</span>
extends java.lang.Object
implements java.lang.Cloneable</pre>
<div class="block"><h1>Fundamental components of <code>scarpet</code> programming language (version 1.6).</h1>

 <p>Scarpet (a.k.a. Carpet Script, or Script for Carpet) is a programming language designed to provide
 the ability to write custom programs to run within Minecraft and
 interact with the world.</p>

 <p>The project was initially built based on the EvalEx project,
 however it now diverged so far away from the original implementation,
 it would be hard to tell it without this mention.
 EvalEx is a handy expression evaluator for Java, that
 allows to evaluate simple mathematical and boolean expressions.
 For more information, see:
 <a href="https://github.com/uklimaschewski/EvalEx">EvalEx GitHub
 repository</a></p>

 <p>This specification is divided into two sections: this one is agnostic
 to any Minecraft related features and could function on its own, and CarpetExpression for
 Minecraft specific routines and world manipulation functions.</p>

 <h1>Synopsis</h1>

 <pre>
 script run print('Hello World!')
 </pre>
 <p>or an OVERLY complex example:</p>
 <pre>
 /script run
     block_check(x1, y1, z1, x2, y2, z2, block_to_check) -&gt;
     (
         l(minx, maxx) = sort(l(x1, x2));
         l(miny, maxy) = sort(l(y1, y2));
         l(minz, maxz) = sort(l(z1, z2));
         'Need to compute the size of the area of course';
         'Cause this language doesn\'t support comments in the command mode';
         xsize = maxx - minx + 1;
         ysize = maxy - miny + 1;
         zsize = maxz - minz + 1;
         total_count = 0;
         loop(xsize,
             xx = minx + _ ;
             loop(ysize,
                 yy = miny + _ ;
                 loop(zsize,
                     zz = minz + _ ;
                     if ( block(xx,yy,zz) == block_to_check,
                         total_count += ceil(rand(1))
                     )
                 )
             )
         );
         total_count
     );
     check_area_around_closest_player_for_block(block_to_check) -&gt;
     (
         closest_player = player();
         l(posx, posy, posz) = query(closest_player, 'pos');
         total_count = block_check( posx-8,1,posz-8, posx+8,17,posz+8, block_to_check);
         print('There is '+total_count+' of '+block_to_check+' around you')
     )

 /script invoke check_area_around_closest_player_for_block 'diamond_ore'

 </pre>
 <p>or simply</p>
 <pre>
 script run print('There is'+for(rect(x,9,z,8,8,8), _ == 'diamond_ore')+' diamond ore around you')
 </pre>
 <p>It definitely pays to check what higher level <code>scarpet</code> functions have to offer.</p>
 <h1>Programs</h1>
 <p>
 You can think of an program like a mathematical expression, like
 <code>"2.4*sin(45)/(2-4)"</code> or  <code>"sin(y)&gt;0 &amp; max(z, 3)&gt;3"</code>
 Writing a program, is like writing a <code>2+3</code>, just a bit longer</p>

 <h2>Basic language components</h2>
 <p>Programs consist of constants, like <code>2</code>, <code>3.14</code>, <code>pi</code>, or <code>'foo'</code>,
 operators like <code>+</code>, <code>/</code>, <code>-&gt;</code>, variables which you can define, like <code>foo</code>
 or special ones that will be defined for you, like <code>_x</code>, or <code>_</code> , which I specific to
 a each built in function, and functions with name, and arguments in the form of <code>f(a,b,c)</code>, where
 <code>f</code> is the function name, and <code>a, b, c</code> are the arguments which can be any other expression.
 And that's all the parts of the language, so all in all - sounds quite simple.</p>

 <h2>Code flow</h2>
 <p>
     Like any other proper programming language, <code>scarpet</code> needs brackets, basically to identify
     where stuff begins and where it ends. In the languages that uses much more complicated constructs, like Java,
     they tend to use all sort of them, round ones to indicate function calls, curly to indicate section of code,
     square to access lists, pointy for generic types etc... I mean - there is no etc, cause they have exhausted
     all the bracket options...
 </p>
 <p><code>Scarpet</code> is different, since it runs everything based on functions (although its not per se a functional language like lisp)
 only needs the round brackets for everything, and it is up to the programmer to organize its code so its readable,
 as adding more brackets does not have any effect on the performance of the programs as they are compiled before they are executed.
 Look at the following example usage of <code>if()</code> function:
 </p>
 <pre>
 if(x&lt;y+6,set(x,8+y,z,'air');plop(x,top('surface',x,z),z,'birch'),sin(query(player(),'yaw'))&gt;0.5,plop(0,0,0,'boulder'),particle('fire',x,y,z))
 </pre>
 <p>Would you prefer to read</p>
 <pre>
 if(   x&lt;y+6,
            set(x,8+y,z,'air');
            plop(x,top('surface',x,z),z,'birch'),
       sin(query(player(),'yaw'))&gt;0.5,
            plop(0,0,0,'boulder'),
       particle('fire',x,y,z)
 )
 </pre>
 <p>Or rather:</p>
 <pre>
 if
 (
     x&lt;y+6,
     (
         set(x,8+y,z,'air');
         plop(x,top('surface',x,z),z,'birch')
     ),

     sin(query(player(),'yaw'))&gt;0.5,
     (
         plop(0,0,0,'boulder')
     ),

     particle('fire',x,y,z)
 )
 </pre>
 <p>Whichever style you prefer it doesn't matter. It typically depends on the situation and the complexity of the
 subcomponents. No matter how many whitespaces and extra brackets you add - the code will evaluate to exactly the
 same expression, and will run exactly the same, so make sure your programs are nice and clean so others don't
 have problems with them</p>

 <h2>Functions and scoping</h2>
 <p>
 Users can define functions in the form <code>fun(args....) -&gt; expression </code> and they are compiled and saved
 for further execution in this but also subsequent calls of /script command. Functions can also be assigned to variables,
 passed as arguments, called with <code>call</code> function, but in most cases you would want to call them directly
 by name, in the form of <code>fun(args...)</code>.
 This means that once defined functions
 are saved with the world for further use. For variables, there are two types of them,
 global - which are shared anywhere in the code, and those are all which name starts with 'global_', and
 local variables which is everything else and those are only visible inside each function.
 This also means that all the parameters in functions are passed 'by value', not 'by reference'.
 </p>

 <h2>Outer variables</h2>
 <p>Functions can still 'borrow' variables from the outer scope,
 by adding them to the function signature wrapped around built-in function <code>outer</code>.
 It adds the specified value to the function call stack so they behave exactly like capturing lambdas in Java, but
 unlike java captured variables don't need to be final. Scarpet will just attach their new values at the time of the
 function definition, even if they change later. Most value will be copied, but mutable values, like maps or lists, allow
 to keep the 'state' with the function, allowing them to have memory and act like objects so to speak.
 . Check <code>outer(var)</code> for details.</p>


 <h2>Code delivery, line indicators</h2>
 <p>Note that this should only apply to pasting your code to execute with commandblock. Scarpet recommends placing your
 code in apps (files with <code>.sc</code> extension that can be placed inside "/scripts" folder in the world files
 and loaded as a scarpet app with command <code>/script load [app_name]</code>. Scarpet apps loaded from disk should only
 contain code, no need to start with "/script run" prefix</p>
 <p>The following is the code that could be provided in a <code>foo.sc</code> app file located in world <code>/scripts</code> folder</p>

 <pre>
 run_program() -&gt; (
   loop( 10,
     // looping 10 times
     // comments are allowed in scripts located in world files
     // since we can tell where that line ends
     foo = floor(rand(10));
     check_not_zero(foo);
     print(_+' - foo: '+foo);
     print('  reciprocal: '+  _/foo )
   )
 );
 check_not_zero(foo) -&gt; (
   if (foo==0, foo = 1)
 )
 </pre>
 <p>Which we then call in-game with:</p>
 <pre>
     /script load foo
     /script in foo invoke run_program
 </pre>
 <p>However the following code can also be input as a command, or in a command block.</p>

 <p>Since the maximum command that can be input to the chat is limited in length, you will be probably inserting your
 programs by pasting them to command blocks or reading from world files, however pasting to command blocks will remove some whitespaces and squish
 your newlines making the code not readable. If you are pasting a program that is perfect and will never cause an error,
 I salute you, but for the most part it is quite likely that your program might break, either at compile time, when
 its initially analyzed, or at execute time, when you suddenly attempt to divide something by zero. In these cases
 you would want to get a meaningful error message, but for that you would need to indicate for the compiler where
 did you put these new lines, since command block would squish them. For that, place  at the beginning
 of the line to let the compiler know where are you. This makes so that <code>$</code> is the only character that is
 illegal in programs, since it will be replaced with new lines. As far as I know, <code>$</code> is not used
 anywhere inside Minecraft identifiers, so this shouldn't hinder the abilities of your programs.</p>
 <p>Consider the following program executed as command block command:</p>
 <pre>
 /script run
 run_program() -&gt; (
   loop( 10,
     foo = floor(rand(_));
     check_not_zero(foo);
     print(_+' - foo: '+foo);
     print('  reciprocal: '+  _/foo )
   )
 );
 check_not_zero(foo) -&gt; (
    if (foo==0, foo = 1)
 )

 </pre>
 <p>Lets say that the intention was to check if the bar is zero and prevent division by zero in print,
 but because the <code>foo</code> is passed as a variable, it never changes the original foo value.
 Because of the inevitable division by zero, we get the following message:
 </p>
 <pre>
 Your math is wrong, Incorrect number format for NaN at pos 98
 run_program() -> ( loop( 10, foo = floor(rand(_)); check_not_zero(foo); print(_+' - foo: '+foo);
 HERE>> print(' reciprocal: '+ _/foo ) ));check_not_zero(foo) -> ( if (foo==0, foo = 1))
 </pre>

 As we can see, we got our problem where the result of the mathematical operation was not a number (infinity, so not a number),
 however by pasting our program
 into the command made it squish the newlines so while it is clear where the error happened and we still can track the error down,
 the position of the error (98) is not very helpful and wouldn't be useful if the program gets significantly longer.
 To combat this issue we can precede every line of the script with dollar signs <code>$</code>:
 <pre>
 /script run
 $run_program() -&gt; (
 $  loop( 10,
 $    foo = floor(rand(_));
 $    check_not_zero(foo);
 $    print(_+' - foo: '+foo);
 $    print('  reciprocal: '+  _/foo )
 $  )
 $);
 $check_not_zero(foo) -&gt; (
 $   if (foo==0, foo = 1)
 $)
 </pre>

 <p>Then we get the following error message</p>

 <pre>
 Your math is wrong, Incorrect number format for NaN at line 7, pos 2
   print(_+' - foo: '+foo);
    HERE>> print(' reciprocal: '+ _/foo )
   )
 </pre>


 <p>As we can note not only we get much more concise snippet, but also information about the line
 number and position, so means its way easier to locate the potential problems problem</p>

 <p>Obviously that's not the way we intended this program to work. To get it <code>foo</code> modified via
 a function call, we would either return it as a result and assign it to the new variable:
 </p>
 <pre>
     foo = check_not_zero(foo);
     ...
     check_not_zero(foo) -&gt; if(foo == 0, 1, foo)
 </pre>
 <p>.. or convert it to a global variable, which in this case passing as an argument is not required</p>
 <pre>
     global_foo = floor(rand(10));
     check_foo_not_zero();
     ...
     check_foo_not_zero() -&gt; if(global_foo == 0, global_foo = 1)
 </pre>
 </p></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../carpet/script/Expression.html#Expression-java.lang.String-">Expression</a></span>(java.lang.String&nbsp;expression)</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/Expression.html#ArithmeticOperations--">ArithmeticOperations</a></span>()</code>
<div class="block">Arithmetic operations</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/Expression.html#BasicDataStructures--">BasicDataStructures</a></span>()</code>
<div class="block">Lists, Maps and API support for Containers</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/Expression.html#LoopsAndHigherOrderFunctions--">LoopsAndHigherOrderFunctions</a></span>()</code>
<div class="block">Loops, and higher order functions</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/Expression.html#Operators--">Operators</a></span>()</code>
<div class="block">Operators</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/Expression.html#SystemFunctions--">SystemFunctions</a></span>()</code>
<div class="block">System functions</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/Expression.html#UserDefinedFunctionsAndControlFlow--">UserDefinedFunctionsAndControlFlow</a></span>()</code>
<div class="block">User-defined functions and program control flow</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/Expression.html#VariablesAndConstants--">VariablesAndConstants</a></span>()</code>
<div class="block">Variables and Constants</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Expression-java.lang.String-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Expression</h4>
<pre>public&nbsp;Expression(java.lang.String&nbsp;expression)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>expression</code> - .</dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="ArithmeticOperations--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ArithmeticOperations</h4>
<pre>public&nbsp;void&nbsp;ArithmeticOperations()</pre>
<div class="block"><h1>Arithmetic operations</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <h2>Basic Arithmetic Functions</h2>
 <p>There is bunch of them - they require a number and spit out a number,
 doing what you would expect them to do.</p>
 <h3><code>fact(n)</code></h3>
 <p>Factorial of a number, a.k.a <code>n!</code>, just not in <code>scarpet</code>. Gets big... quick...</p>
 <h3><code>sqrt(n)</code></h3>
 <p>Square root. For other fancy roots, use <code>^</code>, math and yo noggin. Imagine square roots on a tree...</p>
 <h3><code>abs(n)</code></h3>
 <p>Absolut value.</p>
 <h3><code>round(n)</code></h3>
 <p>Closest integer value. Did you know the earth is also round?</p>
 <h3><code>floor(n)</code></h3>
 <p>Highest integer that is still no larger then <code>n</code>. Insert a floor pun here.</p>
 <h3><code>ceil(n)</code></h3>
 <p>First lucky integer that is not smalller than <code>n</code>. As you would expect, ceiling is typically
 right above the floor.</p>
 <h3><code>ln(n)</code></h3>
 <p>Natural logarithm of <code>n</code>. Naturally.</p>
 <h3><code>ln1p(n)</code></h3>
 <p>Natural logarithm of <code>n+1</code>. Very optimistic.</p>
 <h3><code>log10(n)</code></h3>
 <p>Decimal logarithm of <code>n</code>. Its ceiling is the length of its floor.</p>
 <h3><code>log(n)</code></h3>
 <p>Binary logarithm of <code>n</code>. Finally, a proper one, not like the previous 11.</p>
 <h3><code>log1p(n)</code></h3>
 <p>Binary logarithm of <code>n+1</code>. Also always positive.</p>
 <h3><code>mandelbrot(a, b, limit)</code></h3>
 <p>Computes the value of the mandelbrot set, for set <code>a</code> and <code>b</code> spot.
 Spot the beetle. Why not.</p>
 <h3><code>min(arg, ...), min(list), max(arg, ...), max(list)</code></h3>
 <p>Compute minimum or maximum of supplied arguments assuming default sorthoraphical order. In case you are
 missing <code>argmax</code>, just use <code>a ~ max(a)</code>, little less efficient, but still fun.
 </p>
 <p>
 Interesting bit - <code>min</code> and <code>max</code> don't remove variable associations from arguments, which
 means can be used as LHS of assignments (obvious case), or argument spec in function definitions (far less obvious).
 </p>
 <pre>
 a = 1; b = 2; min(a,b) = 3; l(a,b)  =&gt; [3, 2]
 a = 1; b = 2; fun(x, min(a,b)) -&gt; l(a,b); fun(3,5)  =&gt; [5, 0]
 </pre>
 <p>Absolutely no idea, how the latter might be useful in practice. But since it compiles, can ship it.</p>

 <h3><code>relu(n)</code></h3>
 <p>Linear rectifier of <code>n</code>. 0 below 0, n above. Why not. <code>max(0,n)</code>
 with less moral repercussions.</p>
 <h2>Trigonometric / Geometric Functions</h2>
 <h3><code>sin(x)</code></h3>
 <h3><code>cos(x)</code></h3>
 <h3><code>tan(x)</code></h3>
 <h3><code>asin(x)</code></h3>
 <h3><code>acos(x)</code></h3>
 <h3><code>atan(x)</code></h3>
 <h3><code>atan2(x,y)</code></h3>
 <h3><code>sinh(x)</code></h3>
 <h3><code>cosh(x)</code></h3>
 <h3><code>tanh(x)</code></h3>
 <h3><code>sec(x)</code></h3>
 <h3><code>csc(x)</code></h3>
 <h3><code>sech(x)</code></h3>
 <h3><code>csch(x)</code></h3>
 <h3><code>cot(x)</code></h3>
 <h3><code>acot(x)</code></h3>
 <h3><code>coth(x)</code></h3>
 <h3><code>asinh(x)</code></h3>
 <h3><code>acosh(x)</code></h3>
 <h3><code>atanh(x)</code></h3>
 <h3><code>rad(deg)</code></h3>
 <h3><code>deg(rad)</code></h3>
 <p>Use as you wish</p>

 </div></div>
</li>
</ul>
<a name="BasicDataStructures--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BasicDataStructures</h4>
<pre>public&nbsp;void&nbsp;BasicDataStructures()</pre>
<div class="block"><h1>Lists, Maps and API support for Containers</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <p>Scarpet supports basic container types: lists and maps (aka hashmaps, dicts etc..)</p>
 <h2>Container manipulation</h2>
 <p>Here is a list of operations that work on all types of containers: lists, maps, as well as other Minecraft
 specific modifyable containers, like NBTs</p>

 <h3><code>get(container, address, ...), get(lvalue), ':' operator</code></h3>
 <p>Returns the value at <code>address</code> element from the <code>value</code>.
 For lists it indicates an index, use negative numbers to reach elements from the end of the list. <code>get</code>
 call will always be able to find the index. In case there is few items, it will loop over </p>
 <p>for maps, retrieves the value under the key specified in the <code>address</code> or null otherwise</p>
 <p>[Minecraft specific usecase]: In case <code>value</code> is of <code>nbt</code> type, uses address as the
 nbt path to query,
 returning null, if path is not found, one value if there was one match, or list of values if result is a list.
 Returned elements can be of numerical type, string texts, or another compound nbt tags</p>
 <p>In case to simplify the access with nested objects, you can add chain of addresses to the arguments of
 <code>get</code> rather than calling it multiple times. <code>get(get(foo,a),b)</code> is equivalent to
 <code>get(foo, a, b)</code>, or <code>foo:a:b</code>.</p>
 <pre>
     get(l(range(10)), 5)  =&gt; 5
     get(l(range(10)), -1)  =&gt; 9
     get(l(range(10)), 10)  =&gt; 0
     l(range(10)):93  =&gt; 3

     get(player() ~ 'nbt', 'Health') =&gt; 20 // inefficient way to get player health, use player() ~ 'health' instead

     get(m( l('foo',2), l('bar',3), l('baz',4) ), 'bar')  =&gt; 3
 </pre>

 <h3><code>has(container, address, ...), has(lvalue)</code></h3>
 <p>Similar to <code>get</code>, but returns boolean value indicating if the given index / key / path is in the
 container. Can be used to determine if <code>get(...)==null</code> means the element doesn't exist, or the stored value
 for this address is <code>null</code>, and is cheaper to run than <code>get</code>.</p>
 <p>Like get, it can accept multiple addresses for chains in nested containers. In this case <code>has(foo:a:b)</code>
 is equivalent to <code>has(get(foo,a), b)</code> or <code>has(foo, a, b)</code></p>

 <h3><code>delete(container, address, ...), delete(lvalue)</code></h3>
 <p>Removes specific entry from the container. For the lists - removes the element and shrinks it. For maps, it
 removes the key from the map, and for nbt - removes content from a given path. For lists and maps returns previous
 entry at the address, for nbt's - number of removed objects, with 0 indicating that the original value was unaffected.</p>
 <p>Like with the <code>get</code> and <code>has</code>, <code>delete</code> can accept chained addresses, as well as
 l-value container access, removing the value
 from the leaf of the path provided, so <code>delete(foo, a, b)</code> is the same as <code>delete(get(foo,a),b)</code>
 or <code>delete(foo:a:b)</code></p>
 <p>Returns true, if container was changed, false, if it was left unchanged, and null if operation was invalid.</p>

 <h3><code>put(container, address, value), put(container, address, value, mode), put(lvalue, value)</code></h3>
 <p><u><b>Lists</b></u></p>
 <p>Modifies the container by replacing the value under the address with the supplied <code>value</code>.
 For lists, a valid index is required, but can be negative as well to indicate positions from the end of the list.
 If <code>null</code> is supplied as the address, it always means - add to the end of the list. </p>
 <p>There are three modes that lists can have items added to them:
 <ul>
     <li><code>replace</code>(default): Replaces item under given index(address). Doesn't change the size of the array
     unless <code>null</code> address is used, which is an exception and then it appends to the end</li>
     <li><code>insert</code>: Inserts given element at a specified index, shifting the rest of the array to make space
     for the item. Note that index of -1 points to the last element of the list, thus inserting at that position and
     moving the previous last element to the new last element position. To insert at the end, use <code>+=</code>
     operator, or <code>null</code> address in put</li>
     <li><code>extend</code>: treats the supplied value as an iterable set of values to insert at a given index,
     extending the list by this amount of items. Again use <code>null</code> address/index to point to the end of
     the list</li>
 </ul>
 <p>Due to the extra mode parameter, there is no chaining for <code>put</code>, but you can still use l-value
 container access to indicate container and address, so <code>put(foo, key, value)</code> is the same as
 <code>put(foo:key, value)</code> or <code>foo:key=value</code></p>
 <p>Returns true, if container got modified, false otherwise, and null if operation was invalid.</p>

 <p><u><b>Maps</b></u></p>
 <p>For maps there are no modes available (yet, seems there is no reason to). It replaces the value under the supplied
 key (address), or sets it if not currently present.</p>
 <p><u><b>NBT Tags</b></u></p>
 <p>
 The address for nbt values is a valid nbt path that you would use with <code>/data</code> command, and tag is any
 tag that would be applicable for a given insert operation. Note that to distinguish between proper types (like integer
 types, you need to use command notation, i.e. regular ints is <code>123</code>, while byte size int would be <code>123b</code>
 and an explicit string would be <code>"5"</code>, so it helps that scarpet uses single quotes in his strings. Unlike
 for lists and maps, it returns the number of affected nodes, or 0 if none were affected.
 </p>
 <p>There are three modes that NBT tags can have items added to them:
 <ul>
     <li><code>replace</code>(default): Replaces item under given path(address). Removes them first if possible, and then
     adds given element to the supplied position. The target path can indicate compound tag keys, lists, or individual
     elements of the lists.</li>
     <li><code>&lt;N&gt;</code>: Index for list insertions. Inserts given element at a specified index, inside a list
     specified with the path address. Fails if list is not specified. It behaves like <code>insert</code> mode for lists,
     i.e. it is not removing any of the existing elements. Use <code>replace</code> to remove and replace existing element.
     </li>
     <li><code>merge</code>: assumes that both path and replacement target are of compound type (dictionaries, maps,
     <code>{}</code> types), and merges keys from <code>value</code> with the compound tag under the path</li>
 </ul>

 <pre>
     a = l(1, 2, 3); put(a, 1, 4); a  =&gt; [1, 4, 3]
     a = l(1, 2, 3); put(a, null, 4); a  =&gt; [1, 2, 3, 4]
     a = l(1, 2, 3); put(a, 1, 4, 'insert'); a  =&gt; [1, 4, 2, 3]
     a = l(1, 2, 3); put(a, null, l(4, 5, 6), 'extend'); a  =&gt; [1, 2, 3, 4, 5, 6]
     a = l(1, 2, 3); put(a, 1, l(4, 5, 6), 'extend'); a  =&gt; [1, 4, 5, 6, 2, 3]
     a = l(l(0,0,0),l(0,0,0),l(0,0,0)); put(a.1, 1, 1); a  =&gt; [[0, 0, 0], [0, 1, 0], [0, 0, 0]]
     a = m(1,2,3,4); put(a, 5, null); a  =&gt; {1: null, 2: null, 3: null, 4: null, 5: null}
     tag = nbt('{}'); put(tag, 'BlockData.Properties', '[1,2,3,4]'); tag  =&gt; {BlockData:{Properties:[1,2,3,4]}}
     tag = nbt('{a:[{lvl:3},{lvl:5},{lvl:2}]}'); put(tag, 'a[].lvl', 1); tag  =&gt; {a:[{lvl:1},{lvl:1},{lvl:1}]}
     tag = nbt('{a:[{lvl:[1,2,3]},{lvl:[3,2,1]},{lvl:[4,5,6]}]}'); put(tag, 'a[].lvl', 1, 2); tag
          =&gt; {a:[{lvl:[1,2,1,3]},{lvl:[3,2,1,1]},{lvl:[4,5,1,6]}]}
     tag = nbt('{a:[{lvl:[1,2,3]},{lvl:[3,2,1]},{lvl:[4,5,6]}]}'); put(tag, 'a[].lvl[1]', 1); tag
          =&gt; {a:[{lvl:[1,1,3]},{lvl:[3,1,1]},{lvl:[4,1,6]}]}
 </pre>

 <h2>List operations</h2>
 <h3><code>l(values ...), l(iterator) </code></h3>
 <p>Creates a list of values of the expressions passed as parameters. It can be used as an L-value and if all
 elements are variables, you coujld use it to return multiple results from one function call, if that function returns
 a list of results with the same size as the <code>l</code> call uses. In case there is only one argument and it is
 an iterator (vanilla expression specification has <code>range</code>, but Minecraft API implements
 a bunch of them, like <code>diamond</code>), it will convert it to a proper list. Iterators can only be used in
 high order functions, and are treated as empty lists, unless unrolled with <code>l</code></p>
 <pre>
 l(1,2,'foo') =&gt; [1, 2, foo]
 l() =&gt; [] (empty list)
 l(range(10)) =&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
 l(1, 2) = l(3, 4) =&gt; Error: l is not a variable
 l(foo, bar) = l(3,4); foo==3 &amp;&amp; bar==4 =&gt; 1
 l(foo, bar, baz) = l(2, 4, 6); l(min(foo, bar), baz) = l(3, 5); l(foo, bar, baz)  =&gt; [3, 4, 5]
 </pre>
 <p>In the last example <code>l(min(foo, bar), baz)</code> creates a valid L-value, as min(foo, bar) finds the
 lower of the variables (in this case <code>foo</code>) creating a valid assignable L-list of [foo, baz], and these
 values will be assigned new values</p>

 <h3><code>join(delim, list), join(delim, values ...) </code></h3>
 <p>Returns a string that contains joined elements of the list, iterator, or all values, concatenated with <code>delim</code> delimiter</p>
 <pre>
     join('-',range(10))  =&gt; 0-1-2-3-4-5-6-7-8-9
     join('-','foo')  =&gt; foo
     join('-', 'foo', 'bar')  =&gt; foo-bar
 </pre>

 <h3><code>split(delim, expr)</code></h3>
 <p>Splits a string undr <code>expr</code> by <code>delim</code> which can be a regular expression</p>
 <pre>
     split('',foo)  =&gt; [f, o, o]
     split('.','foo.bar')  =&gt; []
     split('\\.','foo.bar')  =&gt; [foo, bar]
 </pre>

 <h3><code>slice(expr, from, to?)</code></h3>
 <p>extracts a substring, or sublist (based on the type of the result of the expression under expr with starting index
 of <code>from</code>, and ending at <code>to</code> if provided, or the end, if omitted</p>
 <pre>
     slice(l(0,1,2,3,4,5), 1, 3)  =&gt; [1, 2, 3]
     slice('foobar', 0, 1)  =&gt; 'f'
     slice('foobar', 3)  =&gt; 'bar'
     slice(range(10), 3, 5)  =&gt; [3, 4, 5]
     slice(range(10), 5)  =&gt; [5, 6, 7, 8, 9]
 </pre>

 <h3><code>sort(list), sort(values ...) </code></h3>
 <p>Sorts in the default sortographical order either all arguments, or a list if its the only argument. It returns a new
 sorted list, not affecting the list passed to the argument</p>
 <pre>
 sort(3,2,1)  =&gt; [1, 2, 3]
 sort('a',3,11,1)  =&gt; [1, 3, 11, 'a']
 list = l(4,3,2,1); sort(list)  =&gt; [1, 2, 3, 4]
 </pre>

 <h3><code>sort_key(list, key_expr)</code></h3>
 <p>Sorts a copy of the list in the order or keys as defined by the <code>key_expr</code> for each element</p>
 <pre>
     sort_key([1,3,2],_)  =&gt; [1, 2, 3]
     sort_key([1,3,2],-_)  =&gt; [3, 2, 1]
     sort_key(l(range(10)),rand(1))  =&gt; [1, 0, 9, 6, 8, 2, 4, 5, 7, 3]
     sort_key(l(range(20)),str(_))  =&gt; [0, 1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3, 4, 5, 6, 7, 8, 9]
 </pre>

 <h3><code>range(to), range(from, to), range(from, to, step)</code></h3>
 <p>Creates a range of numbers from <code>from</code>, no greater/larger than <code>to</code>.
 The <code>step</code> parameter dictates not only the increment size, but also direction (can be negative).
 The returned value is not a proper list, just the iterator
 but if for whatever reason you need a proper list with all items evaluated, use <code>l(range(to))</code>.
 Primarily to be used in higher order functions</p>
 <pre>
     range(10)  =&gt; [...]
     l(range(10))  =&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
     map(range(10),_*_)  =&gt; [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
     reduce(range(10),_a+_, 0)  =&gt; 45
     range(5,10)  =&gt; [5, 6, 7, 8, 9]
     range(20, 10, -2)  =&gt; [20, 18, 16, 14, 12]
 </pre>

 <h3><code>element(list, index)(deprecated)</code></h3>
 <p>Legacy support for older method that worked only on lists. Please use <code>get(...)</code> for equivalent
 support, or <code>.</code> operator. Also previous unique behaviours with <code>put</code> on lists has been
 removed to support all type of container types.</p>

 <h2>Map operations</h2>
 <p>Scarpet supports map structures, aka hashmaps, dicts etc. Map structure can also be used, with <code>null</code>
 values as sets. Apart from container access functions, (<code>. , get, put, has, delete</code>),
 the following functions:</p>
 <h3><code>m(values ...), m(iterator), m(key_value_pairs)  </code></h3>
 <p>creates and initializes a map with supplied keys, and values. If the arguments contains a flat list,
 these are all treated as keys with no value, same goes with the iterator - creates a map that behaves like a set.
 If the arguments is a list of lists, they have to have two elements each, and then first is a key, and second,
 a value</p>
 <pre>
 m(1,2,'foo') =&gt; {1: null, 2: null, foo: null}
 m() =&gt; {} (empty map)
 m(range(10)) =&gt; {0: null, 1: null, 2: null, 3: null, 4: null, 5: null, 6: null, 7: null, 8: null, 9: null}
 m(l(1, 2), l(3, 4)) =&gt; {1: 2, 3: 4}
 reduce(range(10), put(_a, _, _*_); _a, m())
      =&gt; {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
 </pre>
 <h3><code>keys(map), values(map), pairs(map)  </code></h3>
 <p>Returns full lists of keys, values and key-value pairs (2-element lists) for all the entries in the map</p>

 </div></div>
</li>
</ul>
<a name="LoopsAndHigherOrderFunctions--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LoopsAndHigherOrderFunctions</h4>
<pre>public&nbsp;void&nbsp;LoopsAndHigherOrderFunctions()</pre>
<div class="block"><h1>Loops, and higher order functions</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <p>Efficient use of these functions can greatly simplify your programs and speed them up, as these functions
 will internalize most of the operations that need to be applied on multiple values at the same time. Most
 of them take a <code>list</code> argument which can be any iterable structure in scarpet, including
 generators, like <code>rect</code>, or <code>range</code>, and maps, where the iterator returns all the map keys</p>
 <h2>Loops</h2>

 <h3><code>break(), break(expr), continue(), continue(expr)</code></h3>
 <p>These allow to control execution of a loop either skipping current iteration code, using <code>continue</code>, or finishing
 the current loop, using <code>break</code>. <code>break</code> and <code>continue</code> can only be used inside
 <code>for, while, loop, map, filter and reduce</code> functions, while <code>break</code> can be used in <code>first</code> as well.
 Outside of the internal expressions of these functions, calling <code>break</code> or <code>continue</code> will cause an
 error. In case of the nexted loops, and more complex setups, use custom <code>try</code> and <code>throw</code> setup.</p>
 <p>Please check corresponding loop function description what <code>continue</code> and <code>break</code> do in their contexts,
 but in general case, passed values to <code>break</code> and <code>continue</code> will be used in place of the return value of the
 internal iteration expression.</p>


 <h3><code>for(list,expr(_,_i))</code></h3>
 <p>Evaluates expression over list of items from the <code>list</code>. Supplies
 <code>_</code>(value) and <code>_i</code>(iteration number) to the <code>expr</code>.</p>
 <p>Returns the number of times <code>expr</code> was successful. Uses <code>continue</code> and <code>break</code> argument
 in place of the returned value from the <code>expr</code>(if supplied), to determine if the iteration was successful.</p>
 <pre>
     check_prime(n) -&gt; !first( range(2, sqrt(n)+1), !(n % _) );
     for(range(1000000,1100000),check_prime(_))  =&gt; 7216
 </pre>
 <p>From which we can learn that there is 7216 primes between 1M and 1.1M</p>

 <h3><code>while(cond, limit)</code></h3>
 <p>Evaluates expression <code>expr</code> repeatedly until condition <code>cond</code> becomes false,
 but not more than <code>limit</code> times. Returns the result of the last <code>expr</code> evaluation,
 or <code>null</code> if nothing was successful. Both <code>expr</code> and <code>cond</code> will recveived a
 bound variable <code>_</code> indicating current iteration, so its a number.</p>
 <pre>
  while(a&lt;100,10,a=_*_)  =&gt; 81 // loop exhausted via limit
  while(a&lt;100,20,a=_*_)  =&gt; 100 // loop stopped at condition, but a has already been assigned
  while(_*_&lt;100,20,a=_*_)  =&gt; 81 // loop stopped at condition, before a was assigned a value
 </pre>

 <h3><code>loop(num,expr(_),exit(_)?)</code></h3>
 <p>Evaluates expression <code>expr</code>, <code>num</code> number of times.
<code>expr</code> receives <code>_</code> system variable indicating the iteration.</p>
 <pre>
     loop(5, game_tick())  =&gt; repeat tick 5 times
     list = l(); loop(5, x = _; loop(5, list += l(x, _) ) ); list
       // double loop, produces: [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [1, 0], [1, 1], ... , [4, 2], [4, 3], [4, 4]]
 </pre>
 <p>In this small example we will search for first 10 primes, apparently including 0:</p>
 <pre>
     check_prime(n) -&gt; !first( range(2, sqrt(n)+1), !(n % _) );
     primes = l();
     loop(10000, if(check_prime(_), primes += _ ; if (length(primes) &gt;= 10, break())));
     primes

     // outputs: [0, 1, 2, 3, 5, 7, 11, 13, 17, 19]
 </pre>

 <h2>Higher Order Functions</h2>
 <h3><code>map(list,expr(_,_i))</code></h3>
 <p>Converts a <code>list</code> of values, to another list where each value is result of an expression
 <code>v = expr(_, _i)</code> where <code>_</code> is passed as each element of the list, and <code>_i</code> is
 the index of such element. If <code>break</code> is called the map returns whatever collected thus far. If
 <code>continue</code> and <code>break</code> are used with supplied argument, it is used in place of the resulting
 map element, otherwise current element is skipped.</p>
 <pre>
     map(range(10), _*_)  =&gt; [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
     map(players('*'), _+' is stoopid') [gnembon is stoopid, herobrine is stoopid]
 </pre>

 <h3><code>filter(list,expr(_,_i))</code></h3>
 <p>filters <code>list</code> elements returning only these that return positive result of the <code>expr</code>.
 With <code>break</code> and <code>continue</code> statements, the supplied value can be used as a boolean check instead.</p>
 <pre>
     filter(range(100), !(_%5), _*_&gt;1000)  =&gt; [0, 5, 10, 15, 20, 25, 30]
     map(filter(entity_list('*'),_=='Witch'), query(_,'pos') )  =&gt; [[1082.5, 57, 1243.5]]
 </pre>

 <h3><code>first(list,expr(_,_i))</code></h3>
 <p>Finds and returns the first item in the list that satisfies <code>expr</code>. It sets <code>_</code> for current element value,
 and <code>_i</code> for index of that element. <code>break</code> can be called inside the iteration code, using its argument
 value instead of the current item. <code>continue</code> has no sense and cannot be called inside <code>first</code> call.</p>
 <pre>
     first(range(1000,10000), n=_; !first( range(2, sqrt(n)+1), !(n % _) ) )  =&gt; 1009 // first prime after 1000
 </pre>
 <p>Notice in the example above, that we needed to rename the outer <code>_</code> to be albe to use in in the inner
 <code>first</code> call</p>


 <h3><code>all(list,expr(_,_i))</code></h3>
 <p>Returns <code>true</code> if all elements on the list satisfy the condition. Its roughly equivalent to
 <code>all(list,expr) &lt;=&gt; for(list,expr)==length(list)</code>. <code>expr</code>
 also receives bound <code>_</code> and <code>_i</code> variables. <code>break</code> and <code>continue</code> have no sense
 and cannot be used inside of <code>expr</code> body.</p>

 <pre>
     all([1,2,3], check_prime(_))  =&gt; 1
     all(neighbours(x,y,z), _=='stone')  =&gt; 1 // if all neighbours of [x, y, z] are stone
     map(filter(rect(0,4,0,1000,0,1000), l(x,y,z)=pos(_); all(rect(x,y,z,1,0,1),_=='bedrock') ), pos(_) )
       =&gt; [[-298, 4, -703], [-287, 4, -156], [-269, 4, 104], [242, 4, 250], [-159, 4, 335], [-208, 4, 416], [-510, 4, 546], [376, 4, 806]]
         // find all 3x3 bedrock structures in the top bedrock layer
     map( filter( rect(0,4,0,1000,1,1000,1000,0,1000), l(x,y,z)=pos(_);
             all(rect(x,y,z,1,0,1),_=='bedrock') &amp;&amp; for(rect(x,y-1,z,1,1,1,1,0,1),_=='bedrock')&lt;8),
        pos(_) )  =&gt; [[343, 3, -642], [153, 3, -285], [674, 3, 167], [-710, 3, 398]]
         // ditto, but requiring at most 7 bedrock block in the 18 blocks below them
 </pre>

 <h3><code>reduce(list,expr(_a,_,_i), initial)</code></h3>
 <p>Applies <code>expr</code> for each element of the list and saves the result in <code>_a</code> accumulator.
 Consecutive calls to <code>expr</code> can access that value to apply more values. You also need to specify
 the initial value to apply for the accumulator. <code>break</code> can be used to terminate reduction prematurely.
 If a value is provided to <code>break</code> or <code>continue</code>, it will be used from now on as a new value for the
 accumulator.</p>
 <pre>
     reduce([1,2,3,4],_a+_,0)  =&gt; 10
     reduce([1,2,3,4],_a*_,1)  =&gt; 24
 </pre>
 </div></div>
</li>
</ul>
<a name="Operators--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Operators</h4>
<pre>public&nbsp;void&nbsp;Operators()</pre>
<div class="block"><h1>Operators</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">

 <p>There is a number of operators you can use inside the expressions. Those could be considered
 generic type operators that apply to most data types. They also follow standard operator
 precedence, i.e. <code>2+2*2</code> is understood as <code>2+(2*2)</code>,
 not <code>(2+2)*2</code>, otherwise they are applied from left to right, i.e.
 <code>2+4-3</code> is interpreted as <code>(2+4)-3</code>, which in case of numbers
 doesn't matter, but since <code>scarpet</code> allows for mixing all value types
 the associativity would matter, and may lead to unintended effects: </p>
 <p>Important operator is function definition <code>-&gt;</code> operator. It will be covered
 in <a href="../../carpet/script/Expression.html#UserDefinedFunctionsAndControlFlow--"><code>UserDefinedFunctionsAndControlFlow()</code></a></p>
 <pre>
 '123'+4-2 =&gt; ('123'+4)-2 =&gt; '1234'-2 =&gt; '134'
 '123'+(4-2) =&gt; '123'+2 =&gt; '1232'
 3*'foo' =&gt; 'foofoofoo'
 1357-5 =&gt; 1352
 1357-'5' =&gt; 137
 3*'foo'-'o' =&gt; 'fff'
 l(1,3,5)+7 =&gt; l(8,10,12)
 </pre>
 <p>As you can see, values can behave differently when mixed with other types
 in the same expression. in case values are of the same types, the result
 tends to be obvious, but <code>Scarpet</code> tries to make sense of whatever it
 has to deal with</p>
 <h2>Operator Precedence</h2>
 <p>
 Here is the complete list of operators in <code>scarpet</code> including control flow operators.
 Note, that commas and brackets are not technically operators, but part of the language,
 even if they look like them:
 </p>
 <ul>
     <li>Match, Get <code>~ :</code></li>
     <li>Unary <code>+ - !</code></li>
     <li>Exponent <code>^</code></li>
     <li>Multiplication <code>* / %</code></li>
     <li>Addition <code>+ -</code></li>
     <li>Comparison <code>== != &gt; &gt;= &lt;= &lt;</code></li>
     <li>Logical And<code>&amp;&amp;</code></li>
     <li>Logical Or <code>||</code></li>
     <li>Assignment <code>= += &lt;&gt;</code></li>
     <li>Definition <code>-&gt;</code></li>
     <li>Next statement<code>;</code></li>
     <li>Comma <code>,</code></li>
     <li>Bracket <code>( )</code></li>
 </ul>

 <h3><code>Get, Accessor Operator  :</code></h3>
 <p>Operator version of the <code>get(...)</code> function to access elements of lists, maps, and potentially other
 containers (i.e. NBTs). It is important to distinguish from <code>~</code> operator, which is a matching operator,
 which is expected to perform some extra computations to retrieve the result, while <code>:</code> should be
 straightforward and immediate, and the source object should behave like a container and support full container
 API, meaning <code>get(...)</code>, <code>put(...)</code>, <code>delete(...)</code>,
 and <code>has(...)</code> functions</p>
 <p>For certain operators and functions (get, put, delete, has, =, +=) objects can use <code>:</code> annotated
 fields as l-values, meaning construct like <code>foo:0 = 5</code>, would act like <code>put(foo, 0, 5)</code>,
 rather than <code>get(foo, 0) = 5</code>, which would result in an error.</p>
 <p>TODO: add more information about l-value behaviour.</p>

 <h3><code>Matching Operator  ~</code></h3>
 <p>This operator should be understood as 'matches', 'contains', 'is_in',
 or 'find me some stuff about something else. For strings it matches the right operand as a regular
 expression to the left, returning the first match. This can be used to extract information from unparsed nbt's
 in a more convoluted way (use <code>get(...)</code> for more appropriate way of doing it).
 For lists it checks if an element is in the list, and returns the index of that element,
 or <code>null</code> if no such element was found, especially that the use of <code>first(...)</code> function will not
 return the index. Currently it doesn't have any special behaviour for numbers - it checks for existence of characters
 in string representation of the left operand with respect of the regular expression on the right hand side.
 string</p>
 <p>in Minecraft API portion <code>entity ~ feature</code> is a shortcode for <code>query(entity,feature)</code>
 for queries that do not take any extra arguments.</p>
 <pre>
 l(1,2,3) ~ 2  =&gt; 1
 l(1,2,3) ~ 4  =&gt; null
 'foobar' ~ '.b'  =&gt; 'ob'
 player('*') ~ 'gnembon'  // null unless player gnembon is logged in (better to use player('gnembon') instead
 p ~ 'sneaking' // if p is an entity returns whether p is sneaking
 </pre>
 <p>Or a longer example of an ineffective way to searching for a squid</p>
 <pre>
 entities = entities_area('all',x,y,z,100,10,100);
 sid = entities ~ 'Squid';
 if(sid != null, run('execute as '+query(get(entities,sid),'id')+' run say I am here '+query(get(entities,sid),'pos') ) )
 </pre>
 <p>Or an example to find if a player has specific enchantment on a held axe (either hand) and get its level
 (not using proper NBTs query support via <code>get(...)</code>):</p>
 <pre>
 global_get_enchantment(p, ench) -&gt; (
 $   for(l('main','offhand'),
 $      holds = query(p, 'holds', _);
 $      if( holds,
 $         l(what, count, nbt) = holds;
 $         if( what ~ '_axe' &amp;&amp; nbt ~ ench,
 $            lvl = max(lvl, number(nbt ~ '(?&lt;=lvl:)\\d') )
 $         )
 $      )
 $   );
 $   lvl
 $);
 /script run global_get_enchantment(players(), 'sharpness')
 </pre>

 <h3><code>Basic Arithmetic Operators  +  -  *  /</code></h3>
 <p>Allows to add the results of two expressions. If the operands resolve to numbers, the result is
 arithmetic operation.
 In case of strings, adding or subtracting from a string results in string concatenation and
 removal of substrings from that string. Multiplication of strings and numbers results in repeating the
 string N times and division results in taking the first k'th part of the string, so that <code>str*n/n ~ str</code>
 In case first operand is a list, either it results in a new list
 with all elements modified one by one with the other operand, or if the operand is a list with the same number of
 items - elementwise addition/subtraction</p>
 <p>Examples:</p>
 <pre>
 2+3 =&gt; 5
 'foo'+3+2 =&gt; 'foo32'
 'foo'+(3+2) =&gt; 'foo5'
 3+2+'bar' =&gt; '5bar'
 'foo'*3 =&gt; 'foofoofoo'
 'foofoofoo' / 3 =&gt; 'foo'
 'foofoofoo'-'o' =&gt; 'fff'
 l(1,2,3)+1  =&gt; l(2,3,4)
 b = l(100,63,100); b+l(10,0,10)  =&gt; l(110,63,110)
 </pre>

 <h3><code>Just Operators  %  ^</code></h3>
 <p>The modulo and exponent (power) operators work only if both operands are numbers</p>
 <pre>
 pi^pi%euler  =&gt; 1.124....
 -9 % 4  =&gt; -1
 9 % -4  =&gt; 0 ¯\_(ツ)_/¯ Java
 -3 ^ 2  =&gt; 9
 -3 ^ pi =&gt; // Error
 </pre>

 <h3><code>Comparison Operators  ==  !=  &lt;  &gt;  &lt;=  &gt;=</code></h3>
 <p>Allows to compare the results of two expressions.
 For numbers it is considers arithmetic order of numbers, for strings - lexicographical,
 nulls are always 'less' than everything else, and lists check their elements - if the sizes
 are different, the size matters, otherwise, pairwise comparisons for each elements are performed.
 The same order rules than with all these operators are used with the default sortographical order as
 used by <code>sort</code> function. All of these are true:
 </p>
 <pre>
 null == null
 null != false
 0 == false
 1 == true
 null &lt; 0
 null &lt; -1000
 1000 &lt; 'a'
 'bar' &lt; 'foo'
 3 == 3.0
 </pre>

 <h3><code>Logical Operators  &amp;&amp;   ||</code></h3>
 <p>These operator compute respective boolean operation on the operands. What it important is that if calculating
 of the second operand is not necessary, it won't be evaluated, which means one can use them as conditional
 statements. In case of success returns first positive operand (<code>||</code>) or last one (<code>&amp;&amp;</code>).</p>
 <pre>
 true || false  =&gt; 1
 null || false =&gt; 0
 null != false || run('kill gnembon')  =&gt; 1 // gnembon survives
 null != false &amp;&amp; run('kill gnembon')  =&gt; 0 // when cheats not allowed
 null != false &amp;&amp; run('kill gnembon')  =&gt; 1 // gnembon dies, cheats allowed
 </pre>


 <h3><code>Assignment Operators  =  &lt;&gt;  +=</code></h3>
 <p>A set of assignment operators. All require bounded variable on the LHS, <code>&lt;&gt;</code> requires
 bounded arguments on the right hand side as well (bounded, meaning being variables). Additionally they can also
 handle list constructors with all bounded variables, and work then as list assignment operators.
 When <code>+=</code> is used on a list, it extends that list of that element, and returns the list (old == new).
 <code>scarpet</code> doesn't support currently removal of items. Removal of items can be obtaine via
 <code>filter</code> command, and reassigning it fo the same variable. Both operations would require rewriting of the
 array anyways.</p>
 <pre>
 a = 5  =&gt; a == 5
 l(a,b,c) = l(3,4,5) =&gt; a==3, b==4, c==5
 l(minx,maxx) = sort(xi,xj);  // minx assumes min(xi, xj) and maxx, max(xi, xj)
 l(a,b,c,d,e,f) = l(range(6)); l(a,b,c) &lt;&gt; l(d,e,f); l(a,b,c,d,e,f)  =&gt; [3,4,5,0,1,2]
 a = l(1,2,3); a += 4  =&gt; [1,2,3,4]
 a = l(1,2,3,4); a = filter(a,_!=2)  =&gt; [1,3,4]
 </pre>
 <h3><code>Unary Operators  -  +</code></h3>
 <p>Require a number, flips the sign. One way to assert it's a number is by crashing the script. gg.</p>
 <pre>
 -4  =&gt; -4
 +4  =&gt; 4
 +'4'  // Error message
 </pre>

 <h3><code>Negation Operator  !</code></h3>
 <p>flips boolean condition of the expression. Equivalent of <code>bool(expr)==false</code></p>
 <pre>
 !true  =&gt; 0
 !false  =&gt; 1
 !null  =&gt; 1
 !5  =&gt; 0
 !l() =&gt; 1
 !l(null) =&gt; 0
 </pre>
 </div></div>
</li>
</ul>
<a name="SystemFunctions--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SystemFunctions</h4>
<pre>public&nbsp;void&nbsp;SystemFunctions()</pre>
<div class="block"><h1>System functions</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <h2>Type conversion functions</h2>
 <h3><code>copy(expr)</code></h3>
 <p>Returns the deep copy of the expression. Can be used to copy mutable objects, like maps and lists</p>
 <h3><code>type(expr)</code></h3>
 <p>Returns the string value indicating type of the expression. Possible outcomes are
 <code>null, number, string, list, iterator</code>, as well as minecraft related concepts like
 <code>block, entity, nbt</code></p>
 <h3><code>bool(expr)</code></h3>
 <p>Returns a boolean context of the expression. Note that there are no true/false values in
 scarpet. <code>true</code> is alias of 1, and <code>false</code> is 0. Bool is also interpreting
 string values as boolean, which is different from other places where boolean context can be used.
 This can be used in places where API functions return string values to represent binary values</p>
 <pre>
 bool(pi) =&gt; 1
 bool(false) =&gt; 0
 bool('') =&gt; 0
 bool(l()) =&gt; 0
 bool(l('')) =&gt; 1
 bool('foo') =&gt; 1
 bool('false') =&gt; 0
 bool('nulL') =&gt; 0
 if('false',1,0) =&gt; 1
 </pre>

 <h3><code>number(expr)</code></h3>
 <p>Returns a numeric context of the expression.
 Can be used to read numbers from strings</p>
 <pre>
 number(null) =&gt; null
 number(false) =&gt; 0
 number('') =&gt; null
 number('3.14') =&gt; 3.14
 number(l()) =&gt; 0
 number(l('')) =&gt; 1
 number('foo') =&gt; null
 number('3bar') =&gt; null
 number('2')+number('2') =&gt; 4
 </pre>

 <h3><code>str(expr, params? ... ), str(expr, param_list)</code></h3>

 <p>Returns a formatted string representing expression.
 Accepts formatting style accepted by <code>String.format</code>.
 Supported types (with <code>"%?"</code> syntax):</p>
 <ul>
     <li>d, o, x: integers</li>
     <li>a, e, f, g: floats</li>
     <li>b: booleans</li>
     <li>s: strings</li>
 </ul>

 <pre>
 str(null) =&gt; null
 str(false) =&gt; 0
 str('') =&gt; null
 str('3.14') =&gt; 3.14
 str(l()) =&gt; 0
 str(l('')) =&gt; 1
 str('foo') =&gt; null
 str('3bar') =&gt; null
 str(2)+str(2) =&gt; 22
 str('pi: %.2f',pi) =&gt; 'pi: 3.14'
 str('player at: %d %d %d',pos(player())) =&gt; 'player at: 567, -2423, 124'
 </pre>

 <hr>
 <h2>Auxiliary functions</h2>

 <h3><code>lower(expr), upper(expr), title(expr)</code></h3>
 <p>Returns lowercase, uppercase or titlecase representation of a string representation of the passed expression</p>
 <pre>
 lower('aBc') =&gt; 'abc'
 upper('aBc') =&gt; 'ABC'
 title('aBc') =&gt; 'Abc'
 </pre>

 <h3><code>replace(string, regex, repl?); replace_first(string, regex, repl?)</code></h3>
 <p>Replaces all, or first occurence of a regular expression in the string with <code>repl</code> expression, or
 nothing, if not specified</p>
 <pre>
 replace('abbccddebfg','b+','z')  // =&gt; azccddezfg
 replace_first('abbccddebfg','b+','z')  // =&gt; azccddebfg
 </pre>

 <h3><code>length(expr)</code></h3>
 <p>Returns length of the expression, the length of the string,
 the length of the integer part of the number, or length of the list</p>
 <pre>
 length(pi) =&gt; 1
 length(pi*pi) =&gt; 1
 length(pi^pi) =&gt; 2
 length(l()) =&gt; 0
 length(l(1,2,3)) =&gt; 3
 length('') =&gt; 0
 length('foo') =&gt; 3
 </pre>

 <h3><code>rand(expr)</code></h3>
 <p>returns a random number from <code>0.0</code>
 (inclusive) to <code>expr</code> (exclusive).
 In boolean context (in conditions, boolean functions, or <code>bool</code>), returns
 false if the randomly selected value is less than 1. This means that <code>rand(2)</code> returns true half
 of the time and <code>rand(5)</code> returns true for 80% (4/5) of the time</p>
 <pre>
 map(range(10), floor(rand(10))) =&gt; [5, 8, 0, 6, 9, 3, 9, 9, 1, 8]
 map(range(10), bool(rand(2))) =&gt; [1, 1, 1, 0, 0, 1, 1, 0, 0, 0]
 map(range(10), str('%.1f',rand(_))) =&gt; [0.0, 0.4, 0.6, 1.9, 2.8, 3.8, 5.3, 2.2, 1.6, 5.6]
 </pre>

 <h3><code>print(expr)</code></h3>
 <p>prints the value of the expression to chat.
 Passes the result of the argument to the output unchanged, so <code>print</code>-statements can
 be weaved in code to debug programming issues</p>
 <pre>
     print('foo') =&gt; results in foo, prints: foo
     a = 1; print(a = 5) =&gt; results in 5, prints: 5
     a = 1; print(a) = 5 =&gt; results in 5, prints: 1
     print('pi = '+pi) =&gt; prints: pi = 3.141592653589793
     print(str('pi = %.2f',pi)) =&gt; prints: pi = 3.14
 </pre>

 <h3><code>sleep(expr)</code></h3>
 <p>Halts the execution of the program (and the game itself) for <code>expr</code> milliseconds.
 All in all, its better to use <code>game_tick(expr)</code> to let the game do its job while the program waits</p>
 <pre>sleep(50)</pre>
 <h3><code>time()</code></h3>
 <p>Returns the number of milliseconds since 'some point',
 like Java's <code>System.nanoTime()</code>. It returns a float, which has 1 microsecond precision
 (0.001 ms)</p>
 <pre>
     start_time = time();
     flip_my_world_upside_down();
     print(str('this took %d milliseconds',time()-start_time))
 </pre>

 <h3><code>profile_expr(expression)</code></h3>
 <p>Returns number of times given expression can be run in 50ms time. Useful to profile and optimize your
 code. Note that, even if its only a number, it WILL run these commands, so if they are destructive,
 you need to be careful.</p>

 <hr>
 <h2>Access to variables and stored functions (use with caution)</h2>

 <h3><code>var(expr)</code></h3>
 <p>Returns the variable under the name of the string value of the expression. Allows to
 manipulate variables in more programmatic manner, which allows to use local variable set with a
 hash map type key-value access, can also be used with global variables</p>
 <pre>
     a = 1; var('a') = 'foo'; a =&gt; a == 'foo'
 </pre>

 <h3><code>undef(expr)</code></h3>
 <p>Removes all bindings of a variable with a name of <code>expr</code>.
 Removes also all function definitions with that name. It can affect global variable pool, and local variable set
 for a particular function which will become invalid ........, </p>
 <pre>
     inc(i) -&gt; i+1; foo = 5; inc(foo) =&gt; 6
     inc(i) -&gt; i+1; foo = 5; undef('foo'); inc(foo) =&gt; 1
     inc(i) -&gt; i+1; foo = 5; undef('inc'); undef('foo'); inc(foo) =&gt; Error: Function inc is not defined yet at pos 53
     undef('pi')  =&gt; bad idea - removes hidden variable holding the pi value
     undef('true')  =&gt; even worse idea, unbinds global true value, all references to true would now refer to the default 0
 </pre>
 <h3><code>vars(prefix)</code></h3>
 <p>It returns all names of variables from local scope (if prefix does not start with 'global')
 or global variables (otherwise).
 Here is a larger example that uses combination of <code>vars</code> and <code>var</code> functions to
 be used for object counting</p>
 <pre>
 /script run
 $ count_blocks(ent) -&gt; (
 $   l(cx, cy, cz) = query(ent, 'pos');
 $   scan(cx, cy, cz, 16, 16, 16, var('count_'+_) += 1);
 $   for ( sort_key( vars('count_'), -var(_)),
 $     print(str( '%s: %d', slice(_,6), var(_) ))
 $   )
 $ )

 /script run count_blocks(player())
 </pre>

 </div></div>
</li>
</ul>
<a name="UserDefinedFunctionsAndControlFlow--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>UserDefinedFunctionsAndControlFlow</h4>
<pre>public&nbsp;void&nbsp;UserDefinedFunctionsAndControlFlow()</pre>
<div class="block"><h1>User-defined functions and program control flow</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <h2>Writing programs with more than 1 line</h2>
 <h3><code>Operator ;</code></h3>
 <p>To effectively write programs that have more than one line, a programmer needs way to specify a sequence of
 commands that execute one after another. In <code>scarpet</code> this can be achieved with <code>;</code>. Its an operator,
 and by separating statements with semicolons. And since whitespaces and <code>$</code> signs are all treats as
 whitespaces, how you layout your code doesn't matter, as long as it is readable to everyone involved.</p>
 <pre>
 expr;
 expr;
 expr;
 expr
 </pre>
 <p>Notice that the last expression is not followed by a semicolon. Since instruction separation is functional
 in <code>scarpet</code>, and not barely an instruction delimiter, terminating the code with a dangling operator
 wouldn't be valid. Having said that, since many programming languages don't care about the number of op terminators
 programmers use, carpet preprocessor will remove all unnecessary semicolons from scripts when compiled.</p>
 <p>In general <code>expr; expr; expr; expr</code> is equivalent to
 <code>(((expr ; expr) ; expr) ; expr)</code>.</p>
 <p>Result of the evaluated expression is the same as the result of the second expression, but first expression is
 also evaluated for sideeffects</p>
 <pre>
 expr1 ; expr2 =&gt; expr2  // with expr1 as a sideeffect
 </pre>
 <h2>Global variables</h2>
 <p>All defined functions are compiled, stored persistently, and available globally -
 accessible to all other scripts. Functions can only be undefined via call to <code>undef('fun')</code>, which
 would erase global entry for function <code>fun</code>. Since all variables have local scope inside each function,
 one way to share large objects is via global variables
 </p>
 <p>Any variable that is used with a name that starts with <code>'global_'</code> will be stored and accessible globally,
 not, inside current scope. It will also persist across scripts, so if a procedure needs to use its own construct, it needs to
 define it, or initialize it explicitly, or undefine it via <code>undef</code></p>
 <pre>
 a() -&gt; global_list+=1; global_list = l(1,2,3); a(); a(); global_list  // =&gt; [1,2,3,1,1]
 </pre>
 <h3><code>Operator -&gt;</code></h3>
 <p>To organize code better than a flat sequence of operations, one can define functions. Definition is correct if
 has the following form</p>
 <pre>
     fun(args, ...) -&gt; expr
 </pre>
 <p>Where <code>fun(args, ...)</code> is a function signature indicating function name, number of arguments,
 and their names, and expr is an expression (can be complex) that is evaluated when <code>fun</code> is called.
 Names in the signature don't need to be used anywhere else, other occurrences of these names
 will be masked in this function scope.
 Function call creates new scope for variables inside <code>expr</code>, so all non-global variables are not
 visible from the caller scope. All parameters are passed by value to the new scope, including lists and other
 containers, however their copy will be shallow.</p>
 <p>The function returns its name as a string, which means it can be used to call it later with the <code>call</code> function</p>
 <p>Using <code>_</code> as the function name creates anonymous function, so each time <code>_</code> function is defined,
 it will be given a unique name, which you can pass somewhere else to get this function <code>call</code>ed.</p>
 <pre>
 a(lst) -&gt; lst+=1; list = l(1,2,3); a(list); a(list); list  // =&gt; [1,2,3]
 </pre>
 <p>In case the inner function wants to operate and modify larger objects, lists from the outer
 scope, but not global, it needs to use <code>outer</code> function in function signature</p>
 <h3><code>outer(arg)</code></h3>
 <p><code>outer</code> function can only be used in the function signature, and it will
 cause an error everywhere else. It saves the value of that variable from the outer scope and allows
 its use in the inner scope. This is a similar behaviour to using outer variables in lambda function definitions
 from Java, except here you have to specify which variables you want to use, and borrow</p>
 <p>This mechanism can be used to use static mutable objects without the need of using <code>global_...</code> variables</p>
 <pre>
 list = l(1,2,3); a(outer(list)) -&gt; list+=1;  a(); a(); list  // =&gt; [1,2,3,1,1]
 </pre>
 <p>The return value of a function is the value of the last expression. This as the same effect as using outer
 or global lists, but is more expensive</p>
 <pre>
 a(lst) -&gt; lst+=1; list = l(1,2,3); list=a(list); list=a(list); list  // =&gt; [1,2,3,1,1]
 </pre>
 <p>Ability to combine more statements into one expression, with functions, passing parameters, and global and outer
 scoping allow to organize even larger scripts</p>
 <h3><code>call(function, args.....)</code></h3>
 <p>calls a user defined function with specified arguments. It is equivalent to calling <code>function(args...)</code>
 directly except you can use it with function value, or name instead. This means you can pass functions to other user defined
 functions as arguments and call them with <code>call</code> internally. And since function definitions return the
 defined function, they can be defined in place as anonymous functions.</p>
 <p>Little technical note: the use of <code>_</code> in expression passed to built in functions is much more efficient due to
 not creating new call stacks for each invoked function, but anonymous functions is the only mechanism available
 for programmers with their own lambda arguments</p>
 <pre>
 my_map(list, function) -&gt; map(list, call(function, _));
 my_map(l(1,2,3), _(x) -&gt; x*x);    // =&gt; [1,4,9]

 profile_expr(my_map(l(1,2,3), _(x) -&gt; x*x));   // =&gt; ~32000
 sq(x) -&gt; x*x; profile_expr(my_map(l(1,2,3), 'sq'));   // =&gt; ~36000
 sq = (_(x) -&gt; x*x); profile_expr(my_map(l(1,2,3), sq));   // =&gt; ~36000
 profile_expr(map(l(1,2,3), _*_));   // =&gt; ~80000

 </pre>
 <h2>Control flow</h2>
 <h3><code>return(expr?)</code></h3>
 <p>Sometimes its convenient to break the organized control flow, or it is not practical to pass
 the final result value of a function to the last statement, in this case a return statement can be used</p>
 <p>If no argument is provided - returns null value.</p>
 <pre>
 def() -&gt; (
  expr1;
  expr2;
  return(expr3); // function terminates returning expr3
  expr4;     // skipped
  expr5      // skipped
 )
 </pre>
 <p>In general its cheaper to leave the last expression as a return value, rather than calling returns everywhere,
 but it would often lead to a messy code.</p>
 <h3><code>exit(expr?)</code></h3>
 <p>It terminates entire program passing <code>expr</code> as the result of the program execution, or null if omitted.</p>
 <h3><code>try(expr, catch_expr(_)?) ... throw(value?)</code></h3>
 <p><code>try</code> function evaluates expression, and continues further unless <code>throw</code> function is called
 anywhere inside <code>expr</code>. In that case the <code>catch_expr</code> is evaluates with <code>_</code> set
 to the argument <code>throw</code> was called with.
 This mechanic accepts skipping thrown value - it throws null instead, and catch expression - then try returns null as well
 This mechanism allows to terminate large portion of a convoluted
 call stack and continue program execution. There is only one level of exceptions currently in carpet, so if the inner
 function also defines the <code>try</code> catchment area, it will received the exception first, but it can technically
 rethrow the value its getting for the outer scope. Unhandled throw acts like an exit statement.</p>
 <h3><code>if(cond, expr, cond?, expr?, ..., default?)</code></h3>
 <p>If statement is a function that takes a number of conditions that are evaluated one after another and if
 any of them turns out true, its <code>expr</code> gets returned, otherwise, if all conditions fail, the return value is
 <code>default</code> expression, or <code>null</code> if default is skipped</p>
 <p><code>if</code> function is equivalent to <code>if (cond) expr; else if (cond) expr; else default;</code>
 from Java, just in a functional form </p>
 </div></div>
</li>
</ul>
<a name="VariablesAndConstants--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>VariablesAndConstants</h4>
<pre>public&nbsp;void&nbsp;VariablesAndConstants()</pre>
<div class="block"><h1>Variables and Constants</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <p><code>scarpet</code> provides a number of constants that can be used literally in scripts</p>
 <ul>
     <li><code>null</code>: nothing, zilch, not even false</li>
     <li><code>true</code>: pure true, or just 1 (one)</li>
     <li><code>false</code>: false truth, or true falsth, 0 (zero) actually</li>
     <li><code>pi</code>: for the fans of perimeters, its a perimeter of an apple pi of diameter 1. About 3.14</li>
     <li><code>euler</code>: clever guy. Derivative of its exponent is goto 1. About 2.72</li>
 </ul>
 <p>Apart from that, there is a bunch of system variables, that start with <code>_</code> that are set by
 <code>scarpet</code> built-ins, like <code>_</code>, typically each consecutive value in loops,
 <code>_i</code> indicating iteration, or <code>_a</code> like an accumulator for <code>reduce</code>
 function. Certain calls to Minecraft specific calls would also set <code>_x</code>,
 <code>_y</code>, <code>_z</code>, indicating block positions. All variables starting with
 <code>_</code> are read-only, and cannot be declared and modified in client code.</p>

 <h2>Literals</h2>
 <p><code>scarpet</code> accepts numeric and string liters constants.
 Numbers look like <code>1, 2.5, -3e-7, 0xff, </code> and are internally represented as Java's <code>double</code>
 but <code>scarpet</code> will try to trim trailing zeros as much as possible so if you need to use them as intergers,
 you can. Strings using single quoting, for multiple reasons, but primarily to allow for easier use of strings inside
 doubly quoted command arguments (when passing a script as a parameter of <code>/script fill</code> for example,
 or when typing in jsons inside scarpet to feed back into a <code>/data merge</code> command for example. Strings also
 use backslashes <code>\</code> for quoting special characters, in both plain strings and regular expressions</p>
 <pre>
 'foo'
 print('This doesn\'t work')
 nbt ~ '\\.foo'   // matching '.' as a '.', not 'any character match'
 </pre>
 </div></div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
</body>
</html>
